<html>
    <style>
        body {
            display:flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap:2rem;
            background-color:antiquewhite;
            min-height: 100vh;
            margin:0;
        }
        #letter-container, #input-container{
            display:flex;
            width:100%;
            flex-direction: row;
            justify-content: center;
        }
        .letter {
            height:100%;
            padding: 0.5rem;
            font-size: x-large;
        }
        .letter-neutral {
            color: gray;
        }
        .letter-incorrect {
            color:rgb(255, 0, 0);
            background-color: rgb(255, 213, 213);
        }
        .letter-correct{
            color:green
        }
        .letter-select {
            background-color: rgb(219, 209, 209);
        }
        .button-container{
            display:flex;
            flex-direction: row;
            width:fit-content;
            gap: 1rem;
        }
    </style>
    <body>
        <div id="letter-container"></div>
        <div class="button-container">
            <!-- <button id="save-button">Save</button> -->
            <button id="clipboard-button">Copy to Clipboard</button>
            <button id="load-button">Load from Clipboard</button>
            <button onclick="console.log(timeData)">Log Time Data</button>
        </div>
        <div id="text-output"></div>
        <script>
            const KEY_NAMES = [
                "z","x","c","v","b","a","s","d","f","g","q","w","e","r","t","_"
            ]
            // to make sure all combinations are covered, make sure the algorithm picks all possible options before repeating.
            const SEQUENCE_LENGTH = 5
            // take in a list of letters
            //how many times the person should retype each sequence
            const REPEAT_AMOUNT = 3
            const letterContainer = document.getElementById("letter-container")
            const letters = letterContainer.getElementsByClassName("letter") //array of letter elements
            const textOutput = document.getElementById("text-output")

            //removes the first item that matches the value
            const arrayRemove = (arr, value) => {
                for (i=0; i<arr.length; i++) {
                    if (arr[i] === value) {
                        arr.splice(i, 1)
                        return arr
                    }
                }
            }

            let combinationOptions = []
            const resetCombinations = () => {
                combinationOptions = []
                for (let key1 of KEY_NAMES) {
                    for (let key2 of KEY_NAMES) {
                        combinationOptions.push(key1 + key2)
                    }
                }
            }
            resetCombinations()

            // return a list of length SEQUENCE_LENGTH filled with random letters from KEY_NAMES
            const chooseLetters = () => {
                let newSequence = [] // list of single letters. The new sequence to be returned
                for (let i=0; i<SEQUENCE_LENGTH; i++) {
                    // all possible sequence pairs that could come next
                    // list of sequence pairs ex: ["ab", "cd"]
                    let nextLetterOptions = []
                    if (newSequence.length === 0) {
                        if (combinationOptions.length === 0) {
                            combinationOptions = [...KEY_NAMES]
                        }
                        nextLetterOptions = [...combinationOptions]
                    } else {
                        //get all available sequence pairs whose first letter matches the most recent letter added to newSequence
                        for (keyName of combinationOptions) {
                            if (keyName[0] === newSequence[newSequence.length - 1]) {
                                nextLetterOptions.push(keyName)
                            }
                        }
                        if (nextLetterOptions.length === 0) {
                            // if there are no possible next letters, reset combinationOptions and try again
                            combinationOptions = [...KEY_NAMES]
                            for (keyName of combinationOptions) {
                                if (keyName[0] === newSequence[newSequence.length - 1]) {
                                    nextLetterOptions.push(keyName)
                                }
                            }
                        }
                    }
                    // push a random element of nextLetterOptions
                    random_index = Math.floor(Math.random() * nextLetterOptions.length)
                    let letterPair = nextLetterOptions[random_index]
                    newSequence.push(letterPair[1]) // add the second letter of the pair
                    arrayRemove(combinationOptions, letterPair) // this letterpair won't be used again
                }
                return newSequence
            }

            //clear all letters within letterContainer
            //container:HTMLElement
            const clearContainer = () => {
                while (letterContainer.firstChild) {
                    letterContainer.removeChild(letterContainer.lastChild);
                }
                currentIndex = null
            }

            // selects which letter the cursor is on
            // index:int
            const selectNext = () => {
                letters[currentIndex].classList.remove("letter-select")
                letters[currentIndex + 1].classList.add("letter-select")
                currentIndex += 1
            }
            //returns bool: If any of the keys were incorrect
            const checkForIncorrect = () => {
                for (let letter of letters) {
                    if (letter.classList.contains("letter-incorrect")) {
                        return true
                    }
                }
                return false
            }
            /**
             * //unlike the python data structure, this one is directional ("ab" != "ba")
             * // Data structure:
             * {
             *    key1a: {
             *         key2a: {"average":float, "datapoints":int}, // "datapoints" = number of datapoints collected
             *         key2b: {...},
             *         key2c: {...},
             *    },
             *    key1b: {
             *         key:{...},
             *         key:{...},
             *         key:{...},
             *    },
             * }
             */
            //obj (timeData) is the datastructure
                //Modifies and returns obj
            //key1:str
            //key2:str
            //time:number = is the time that was just calculated
            //weight:number = how much weight to give to this time value. This is primarily used when adding two datasets together
            const addTime = (obj, key1, key2, time, weight) => {
                if (!(key1 in obj)) {
                    obj[key1] = {[key2]:{"average":time, "datapoints":1}}
                } else if (!(key2 in obj[key1])) {
                    obj[key1][key2] = {"average":time, "datapoints":1}
                } else {
                    average = Number(obj[key1][key2]["average"])
                    datapoints = Number(obj[key1][key2]["datapoints"])
                    //include the new time into the average
                    obj[key1][key2]["average"] = (average * datapoints + time * weight) / (datapoints + weight)
                    obj[key1][key2]["datapoints"] = datapoints + weight
                }
                return obj
            }
            const testAddTime = () => {
                let time_obj = {}
                addTime(time_obj, "1", "1", 1, 1)
                addTime(time_obj, "1", "1", 2, 1)
                addTime(time_obj, "1", "2", 1, 1)
                addTime(time_obj, "1", "2", 2, 1)
                addTime(time_obj, "2", "1", 1, 1)
                addTime(time_obj, "2", "1", 2, 1)
                addTime(time_obj, "2", "2", 1, 1)
                addTime(time_obj, "2", "2", 2, 1)
                console.log(time_obj)
            }
            // testAddTime()
            
            let currentSequence = chooseLetters()
            let currentRepeat = 1
            let currentIndex = null
            // the time it took for each sequence pair.
            // The sequence abc with 3 reptitions would be made of 2x3 array.
                // Ex: abc -> [(rep1)[ab_time, bc_time], (rep2)[ab_time, bc_time], (rep3)[ab_time, bc_time]]
            let currentSequenceTimes = []
            for (i=0; i<REPEAT_AMOUNT; i++) {
                currentSequenceTimes.push([])
            }
            let lastTime = 0
            let lastDelta = 0
            let timeData = {}

            //optional: text. If text is given, it displays the text. Otherwise, it updates to the default message
            const updateTextOutput = (text) => {
                textOutput.textContent = `Current Repeats: ${currentRepeat}, Time for last key pair: ${lastDelta}`
            }
            updateTextOutput()

            const addCurrentSequenceTimes = () => {
                for (i=0; i<SEQUENCE_LENGTH-1; i++) {
                    let key1 = letters[i].textContent
                    let key2 = letters[i+1].textContent
                    //get the max time out of all the trials
                    let time = 0
                    for (j=0; j<REPEAT_AMOUNT; j++) {
                        let x = currentSequenceTimes[j][i];
                        if (x > time) {
                            time = x
                        }
                    }
                    addTime(timeData, key1, key2, time, 1)
                }
            }

            // clears then fills the letter container with the letters in currentSequence
            // currentSequence:array[str] ex: ["a", "b", "c"]
            const resetSequence = () => {
                clearContainer()
                for (letterName of currentSequence) {
                    // create letter
                    let newLetter = document.createElement("div")
                    letterContainer.appendChild(newLetter)
                    newLetter.classList.add("letter", "letter-neutral")
                    newLetter.textContent = letterName
                }
                letters[0].classList.add("letter-select")
                currentIndex = 0
            }
            resetSequence()

            onkeydown = (keyEvent) => {
                if (!(KEY_NAMES.includes(keyEvent.key) || keyEvent.key === " ")) {
                    //disregard invalid inputs
                    return
                }
                
                const currentLetter = letters[currentIndex]
                if (keyEvent.key === currentLetter.textContent || 
                (keyEvent.key === " " && currentLetter.textContent === "_")) {
                    // if current letter is correct
                    currentLetter.classList.add("letter-correct")
                } else {
                    //refresh line immediately if viewer is incorrect
                    resetSequence()
                    //refresh the times only for this rep
                    currentSequenceTimes[currentRepeat-1] = []
                    return
                    // currentLetter.classList.add("letter-incorrect")
                }

                if (currentIndex === 0) {
                    lastTime = Date.now()
                } else {
                    const currentTime = Date.now()
                    lastDelta = currentTime - lastTime
                    updateTextOutput()
                    currentSequenceTimes[currentRepeat-1].push(lastDelta)
                    lastTime = currentTime
                }

                if (currentIndex === letters.length - 1) {
                    //if at end of sequence
                    if (currentRepeat === REPEAT_AMOUNT) {
                        //all repeats completed -> choose a new sequence
                        currentSequence = chooseLetters()
                        currentRepeat = 1
                        updateTextOutput()
                        resetSequence()

                        addCurrentSequenceTimes()
                        //since we're starting over with a new sequence, completely reset currentSequenceTimes
                        // [[],[],[]]
                        currentSequenceTimes = []
                        for (i=0; i<REPEAT_AMOUNT; i++) {
                            currentSequenceTimes.push([])
                        }
                    } else {
                        currentRepeat += 1
                        updateTextOutput()
                        resetSequence()
                    }
                } else {
                    //not at end of sequence -> selectNext
                    selectNext()
                }
            }

            const timeDataToString = () => {
                let content = "_\t"+KEY_NAMES.join("\t")
                for (key2 of KEY_NAMES) {
                    let line = `${key2}`
                    for (key1 of KEY_NAMES) {
                        if (!(key1 in timeData) || !(key2 in timeData[key1])) {
                            line += "\tNA"
                        } else {
                            let data = timeData[key1][key2]
                            line += `\t${data["average"]},${data["datapoints"]}`
                        }
                    }
                    content += `\n${line}`
                }
                return content
            }

            const stringToTimeData = (text) => {
                let outputObj = {}
                let lines = text.split("\r\n")
                //you don't need to slice the headers into [1:] since the index math below already skips the first one
                let headers = lines[0].split("\t")

                for (line of lines.slice(1)) { //skip first line
                    row = line.split("\t")
                    // skip first element.
                    for (let i=1; i<row.length; i++) {
                        const key1 = headers[i]
                        const key2 = row[0]
                        const value = row[i]
                        if (!(key1 in outputObj)) {
                            outputObj[key1] = {}
                        }
                        if (value === "NA") {
                            outputObj[key1][key2] = null
                        } else {
                            const dataList = value.split(",")
                            outputObj[key1][key2] = {"average":Number(dataList[0]), "datapoints":Number(dataList[1])}
                        }
                    }
                }
                return outputObj
            }

            // const saveButton = document.getElementById("save-button")
            // console.log(saveButton)
            // saveButton.onclick = () => {
            //     textOutput.textContent = "Saved to cookie"
            //     // console.log(timeData)
            //     // console.log(timeDataToString())
            //     // document.cookie = timeDataToString()
            //     document.cookie = "hello"
            //     console.log(document.cookie)
            // }
            const clipboardButton = document.getElementById("clipboard-button")
            clipboardButton.onclick = () => {
                navigator.clipboard.writeText(timeDataToString()).then(() => {
                    textOutput.textContent = "Copied to clipboard"
                }).catch((err) => {
                    console.error(`Error in copying text: ${err}`)
                    textOutput.textContent = "Error! Check console"
                })
            }
            const loadButton = document.getElementById("load-button")
            // loading from clipboard adds the clipboard dataset to the current dataset
            loadButton.onclick = () => {
                navigator.clipboard.readText().then((clipText) => {
                    textOutput.textContent = `Loading clipboard: ${clipText.slice(0,20)}...`
                    clipData = stringToTimeData(clipText)
                    for (key1 in clipData) {
                        for (key2 in clipData[key1]) {
                            const value = clipData[key1][key2]
                            if (value === null) {
                                continue
                            }
                            addTime(timeData, key1, key2, Number(value["average"]), Number(value["datapoints"]))
                        }
                    }
                });
            }
        </script>
    </body>
</html>